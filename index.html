<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Sorting Battle Simulator üèÅ</title>
<style>
  :root{
    --bg:#0f1222; --panel:#161932; --accent:#429e26; --muted:#8b90b3;
    --good:#18c79c; --warn:#ffcc00; --danger:#ff6b6b;
  }
  *{box-sizing:border-box;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#0d1020,#0a0d1a);color:#e7e9ff}
  header{padding:16px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #20244a;background:rgba(22,25,50,.7);backdrop-filter: blur(6px);position:sticky;top:0;z-index:5}
  header h1{margin:0;font-size:20px;letter-spacing:.3px}
  header .badge{background:var(--accent);padding:6px 10px;border-radius:999px;font-weight:600;font-size:12px}
  .container{padding:18px;max-width:1200px;margin:0 auto;display:grid;gap:16px}
  .controls{display:grid;grid-template-columns:repeat(12,1fr);gap:12px;background:var(--panel);padding:14px;border-radius:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  .controls > *{min-width:0}
  .controls label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  .controls select,.controls input[type="number"],.controls input[type="text"],.controls button{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #272b57;background:#0e1130;color:#e7e9ff}
  .controls button.primary{background:var(--accent);border-color:transparent;font-weight:700;cursor:pointer}
  .controls button.ghost{background:transparent;border-color:#2d326e;cursor:pointer}
  .controls .row{grid-column:span 3}
  .controls .row.wide{grid-column:span 6}
  .controls .row.actions{grid-column:span 12;display:flex;gap:10px;flex-wrap:wrap}
  .hint{font-size:12px;color:var(--muted)}
  .arena{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .board{background:var(--panel);padding:12px;border-radius:16px;box-shadow:0 6px 24px rgba(0,0,0,.25);display:grid;grid-template-rows:auto auto 1fr auto auto;gap:6px;min-height:420px}
  .board header{display:flex;justify-content:space-between;align-items:center;background:transparent;border:0;padding:0;position:static}
  .meta{display:flex;gap:12px;flex-wrap:wrap;font-size:12px;color:#cdd2ff}
  .pill{border:1px solid #2d326e;border-radius:999px;padding:4px 8px}
  .bars-container{position:relative}
  .bars{position:relative;display:flex;align-items:flex-end;gap:2px;height:260px;background:linear-gradient(180deg,rgba(255,255,255,.02),transparent);border-radius:10px;border:1px dashed #2a2f5b;padding:8px}
  .bar{flex:1;background:linear-gradient(180deg,#6e9bff,#4760ff);border-radius:4px 4px 0 0;transition:height .08s linear, transform .08s linear, background .08s linear}
  .bar.highlight-compare {background: linear-gradient(180deg, #00e5ff, #0091ea);}
  .bar.highlight-swap {background: linear-gradient(180deg, #ff8a8a, #ff5c5c);}
  .bar.highlight-done {background: linear-gradient(180deg, #53e2c2, #18c79c);}
.bar.highlight-pivot {background: linear-gradient(180deg, #b388ff, #7c4dff);}
  .labels{display:flex;justify-content:space-between;font-size:12px;color:#fff;position:relative;top:-5px}
  .labels.highlight{font-size:14px;color:#ffd36a;font-weight:700;top:-12px}
  .array-display{font-size:14px;color:#18c79c;display:flex;flex-wrap:wrap;gap:4px;justify-content:center;margin:4px 0;}
  .footer{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .footer .left, .footer .right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .range{accent-color:var(--accent)}
  .winner{font-weight:800;color:var(--good)}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  @media (max-width: 900px){
    .arena{grid-template-columns:1fr}
    .controls .row{grid-column:span 6}
    .controls .row.actions{grid-column:span 12}
  }
</style>
</head>
<body>

<header>
  <h1>Sorting Battle Simulator </h1>
  <div class="hint">Pick two algorithms and hit <strong>Start Battle</strong> </div>
</header>

<main class="container">
<h1 id="title">Sorting Battle Simulator <span style="color: rgb(199, 63, 63);" id="g2" >- Group 2</span></h1>

<section class="controls" aria-label="Controls">
  <div class="row">
    <label for="algoA">Algorithm A</label>
    <select id="algoA">
      <option>Selection Sort</option>
      <option>Insertion Sort</option>
      <option>Merge Sort</option>
      <option>Quick Sort</option>
    </select>
  </div>
  <div class="row">
    <label for="algoB">Algorithm B</label>
    <select id="algoB">
      <option>Quick Sort</option>
      <option>Merge Sort</option>
      <option>Insertion Sort</option>
      <option>Selection Sort</option>
    </select>
  </div>
  <div class="row">
    <label for="size">Array Size</label>
    <input id="size" type="number" min="5" max="256" step="1" value="6" />
  </div>
  <div class="row">
    <label for="order">Initial Order Of Array</label>
    <select id="order">
      <option value="random">Random</option>
      <option value="reversed">Reversed</option>
      <option value="sorted">Sorted</option>
      <option value="nearly">Nearly Sorted</option>
    </select>
  </div>
  <div class="row wide">
    <label for="speed">Speed (steps/sec)</label>
    <input id="speed" class="range" type="range" min="1" max="120" step="1" value="20" />
  </div>
  <div class="row">
    <label for="sound">Sound</label>
    <select id="sound">
      <option value="on" selected>On</option>
      <option value="off">Off</option>
    </select>
  </div>
  <div class="row">
    <label for="mode">Mode</label>
    <select id="mode">
      <option value="race" selected>Race</option>
      <option value="step">Step-by-Step</option>
    </select>
  </div>
  <div class="row actions">
    <button id="start" class="primary">Start Battle üöÄ</button>
    <button id="pause" class="ghost">Pause ‚è∏</button>
    <button id="resume" class="ghost">Resume ‚ñ∂</button>
    <button id="restart" class="ghost">Restart üîÑ</button>
    <button id="step" class="ghost">Next Step ‚û°Ô∏è</button>
  </div>
</section>

<section class="arena">
<article class="board" id="boardA" aria-label="Algorithm A Board">
  <header>
    <div>
      <strong id="nameA">‚Äî</strong>
      <span class="pill" id="bigOA">O(?)</span>
    </div>
    <div class="meta">
      <span class="pill" id="timeA">Time: 0 ms</span>
      <span class="pill" id="cmpA">Comparisons: 0</span>
      <span class="pill" id="swpA">Swaps: 0</span>
    </div>
  </header>
  <div class="array-display" id="initA">Initial Array: []</div>
  <div class="bars-container">
    <div class="bars" id="barsA" role="img" aria-label="Visualization A"></div>
    <div class="labels" id="labelsA"></div>
  </div>
  <div class="array-display" id="sortedA">Sorted Array: []</div>
  <div class="footer">
    <div class="left"><span id="statusA">Ready</span></div>
    <div class="right"><span id="winnerA" class="winner"></span></div>
  </div>
</article>

<article class="board" id="boardB" aria-label="Algorithm B Board">
  <header>
    <div>
      <strong id="nameB">‚Äî</strong>
      <span class="pill" id="bigOB">O(?)</span>
    </div>
    <div class="meta">
      <span class="pill" id="timeB">Time: 0 ms</span>
      <span class="pill" id="cmpB">Comparisons: 0</span>
      <span class="pill" id="swpB">Swaps: 0</span>
    </div>
  </header>
  <div class="array-display" id="initB">Initial Array: []</div>
  <div class="bars-container">
    <div class="bars" id="barsB" role="img" aria-label="Visualization B"></div>
    <div class="labels" id="labelsB"></div>
  </div>
  <div class="array-display" id="sortedB">Sorted Array: []</div>
  <div class="footer">
    <div class="left"><span id="statusB">Ready</span></div>
    <div class="right"><span id="winnerB" class="winner"></span></div>
  </div>
</article>
</section>
</main>

<script>
const sleep = ms => new Promise(r => setTimeout(r, ms));
const bigOMap = {
  'Selection Sort': 'O(n¬≤)',
  'Insertion Sort': 'O(n¬≤)',
  'Merge Sort': 'O(n log n)',
  'Quick Sort': 'O(n log n)*'
};

// Generate array
function makeArray(n, order = 'random') {
  const arr = Array.from({ length: n }, (_, i) => i + 1);
  if (order === 'sorted') return arr;
  if (order === 'reversed') return arr.reverse();
  if (order === 'nearly') {
    for (let t = 0; t < Math.floor(n * 0.1) + 1; t++) {
      const i = Math.floor(Math.random() * n),
        j = Math.floor(Math.random() * n);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  for (let i = n - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Render bars dynamically
function renderBars(container, values, highlights) {
  const n = values.length;
  if (!container._initialized || container.children.length !== n) {
    container.innerHTML = '';
    for (let i = 0; i < n; i++) {
      const d = document.createElement('div');
      d.className = 'bar';
      container.appendChild(d);
    }
    container._initialized = true;
  }

  const max = Math.max(...values);
  [...container.children].forEach((bar, i) => {
    const h = (values[i] / max) * 100;
    bar.style.height = h + '%';
    bar.classList.remove('highlight-compare', 'highlight-swap', 'highlight-done', 'highlight-pivot');
    // keep default background from CSS; do not set inline background to allow CSS classes to control colors

    if (highlights) {
      if (highlights.type === 'done') bar.classList.add('highlight-done');
      if (highlights.type === 'compare' && (i === highlights.i || i === highlights.j)) bar.classList.add('highlight-compare');
      if (highlights.type === 'swap' && (i === highlights.i || i === highlights.j)) bar.classList.add('highlight-swap');
      if (highlights.type === 'pivot' && i === highlights.i) bar.classList.add('highlight-pivot');
    }
  });
}

// Update labels with index & value on separate lines
function updateLabels(container, arr, highlights) {
  container.innerHTML = '';
  arr.forEach((v, i) => {
    const span = document.createElement('span');
    span.innerHTML = `<div>Index: ${i}</div><div>Value: ${v}</div>`;
    span.style.transition = 'all 0.08s linear';
    span.style.fontSize = '12px';
    span.style.color = '#fff';
    if (highlights && (i === highlights.i || i === highlights.j)) {
      span.style.color = '#ffd36a';
      span.style.fontSize = '14px';
      span.style.fontWeight = '700';
    }
    container.appendChild(span);
  });
}

// Web Audio
let audioCtx = null;
function beep(val, maxVal, type = 'compare') {
  if (document.getElementById('sound').value === 'off') return;
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type === 'swap' ? 'square' : 'sine';
  o.frequency.setValueAtTime(120 + (val / maxVal) * 880, audioCtx.currentTime);
  g.gain.setValueAtTime(0.001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.07);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + 0.08);
}

// Sorting Generators
function* selectionSort(a) {
  let cmp = 0, swp = 0;
  for (let i = 0; i < a.length - 1; i++) {
    let min = i;
    for (let j = i + 1; j < a.length; j++) {
      yield { type: 'compare', i: min, j, meta: { cmp: ++cmp, swp } };
      if (a[j] < a[min]) min = j;
    }
    if (min !== i) {
      [a[i], a[min]] = [a[min], a[i]]; swp++;
      yield { type: 'swap', i, j: min, meta: { cmp, swp } };
    }
  }
  yield { type: 'done' };
}

function* insertionSort(a) {
  let cmp = 0, swp = 0;
  for (let i = 1; i < a.length; i++) {
    let key = a[i]; let j = i - 1;
    while (j >= 0) {
      yield { type: 'compare', i: j, j: j + 1, meta: { cmp: ++cmp, swp } };
      if (a[j] > key) { a[j + 1] = a[j]; swp++; yield { type: 'swap', i: j, j: j + 1, meta: { cmp, swp } }; j--; } else break;
    }
    a[j + 1] = key;
  }
  yield { type: 'done' };
}

function* mergeSort(a) {
  let cmp = 0, swp = 0;
  function* msort(l, r) {
    if (r - l <= 1) return;
    const m = (l + r) >> 1;
    yield* msort(l, m);
    yield* msort(m, r);
    const tmp = [];
    let i = l, j = m;
    while (i < m && j < r) {
      yield { type: 'compare', i, j, meta: { cmp: ++cmp, swp } };
      if (a[i] <= a[j]) tmp.push(a[i++]); else tmp.push(a[j++]);
    }
    while (i < m) tmp.push(a[i++]);
    while (j < r) tmp.push(a[j++]);
    for (let k = 0; k < tmp.length; k++) {
      a[l + k] = tmp[k]; swp++;
      yield { type: 'swap', i: l + k, j: l + k, meta: { cmp, swp } };
    }
  }
  yield* msort(0, a.length);
  yield { type: 'done' };
}

function* quickSort(a) {
  let cmp = 0, swp = 0;
  function* q(l, r) {
    if (l >= r) return;
    const p = a[r]; yield { type: 'pivot', i: r };
    let i = l;
    for (let j = l; j < r; j++) {
      yield { type: 'compare', i: j, j: r, meta: { cmp: ++cmp, swp } };
      if (a[j] < p) { [a[i], a[j]] = [a[j], a[i]]; swp++; yield { type: 'swap', i, j, meta: { cmp, swp } }; i++; }
    }
    [a[i], a[r]] = [a[r], a[i]]; swp++;
    yield { type: 'swap', i, j: r, meta: { cmp, swp } };
    yield* q(l, i - 1);
    yield* q(i + 1, r);
  }
  yield* q(0, a.length - 1);
  yield { type: 'done' };
}

const algoMap = {
  'Selection Sort': selectionSort,
  'Insertion Sort': insertionSort,
  'Merge Sort': mergeSort,
  'Quick Sort': quickSort
};

// UI Elements
const ui = {
  algoA: document.getElementById('algoA'),
  algoB: document.getElementById('algoB'),
  size: document.getElementById('size'),
  order: document.getElementById('order'),
  speed: document.getElementById('speed'),
  start: document.getElementById('start'),
  pause: document.getElementById('pause'),
  resume: document.getElementById('resume'),
  restart: document.getElementById('restart'),
  stepBtn: document.getElementById('step'),
  mode: document.getElementById('mode')
};

// Global state
let state = { running: false, paused: false };
let stepTickets = 0; // permits for step-by-step mode; one ticket = one yielded step for one algorithm

let arrA = [], arrB = [], genA = null, genB = null;

// Reset initial arrays and UI
function resetArrays() {
  arrA = makeArray(+ui.size.value, ui.order.value);
  arrB = [...arrA];
  document.getElementById('initA').textContent = 'Initial Array: [' + arrA.join(',') + ']';
  document.getElementById('initB').textContent = 'Initial Array: [' + arrB.join(',') + ']';
  document.getElementById('sortedA').textContent = 'Sorted Array: []';
  document.getElementById('sortedB').textContent = 'Sorted Array: []';
  renderBars(document.getElementById('barsA'), arrA);
  renderBars(document.getElementById('barsB'), arrB);
  updateLabels(document.getElementById('labelsA'), arrA);
  updateLabels(document.getElementById('labelsB'), arrB);
  document.getElementById('nameA').textContent = ui.algoA.value;
  document.getElementById('nameB').textContent = ui.algoB.value;
  document.getElementById('bigOA').textContent = bigOMap[ui.algoA.value] || 'O(?)';
  document.getElementById('bigOB').textContent = bigOMap[ui.algoB.value] || 'O(?)';
  document.getElementById('statusA').textContent = 'Ready';
  document.getElementById('statusB').textContent = 'Ready';
  document.getElementById('winnerA').textContent = '';
  document.getElementById('winnerB').textContent = '';
}

// Winner logic
let finishedA = false, finishedB = false, winnerDeclared = false;

async function runSorting(gen, arr, container, labels, sortedDisplay, timeDisplay, cmpDisplay, swpDisplay, status, winnerElem) {
  const speed = +ui.speed.value;
  const startTime = performance.now();

  for (let step of gen) {
    // Gate: pause or step-by-step tickets
    while (state.paused || (ui.mode.value === 'step' && stepTickets === 0)) {
      await sleep(20);
    }
    if (ui.mode.value === 'step' && stepTickets > 0) {
      stepTickets--;
    }

    if (step.type === 'compare') beep(arr[step.i], arr.length, 'compare');
    if (step.type === 'swap') beep(arr[step.i], arr.length, 'swap');

    renderBars(container, arr, step);
    updateLabels(labels, arr, step);

    if (step.meta) {
      cmpDisplay.textContent = 'Comparisons: ' + step.meta.cmp;
      swpDisplay.textContent = 'Swaps: ' + step.meta.swp;
    }
    await sleep(1000 / speed);
  }

  const endTime = performance.now();
  sortedDisplay.textContent = 'Sorted Array: [' + arr.join(',') + ']';
  timeDisplay.textContent = 'Time: ' + Math.round(endTime - startTime) + ' ms';
  status.textContent = 'Done';

  if (winnerElem.id === 'winnerA') finishedA = true;
  else finishedB = true;

  if (!winnerDeclared) {
    if (finishedA && !finishedB) {
      document.getElementById('winnerA').textContent = 'Winner üèÜ';
      document.getElementById('winnerB').textContent = '';
    } else if (finishedB && !finishedA) {
      document.getElementById('winnerB').textContent = 'Winner üèÜ';
      document.getElementById('winnerA').textContent = '';
    }
    winnerDeclared = true;
  }
}

// Event listeners
ui.start.addEventListener('click', () => {
  resetArrays();
  state.running = true; state.paused = false;
  winnerDeclared = false; finishedA = false; finishedB = false;
  stepTickets = 0;
  genA = algoMap[ui.algoA.value](arrA);
  genB = algoMap[ui.algoB.value](arrB);
  runSorting(genA, arrA, document.getElementById('barsA'), document.getElementById('labelsA'),
    document.getElementById('sortedA'), document.getElementById('timeA'),
    document.getElementById('cmpA'), document.getElementById('swpA'), document.getElementById('statusA'), document.getElementById('winnerA'));
  runSorting(genB, arrB, document.getElementById('barsB'), document.getElementById('labelsB'),
    document.getElementById('sortedB'), document.getElementById('timeB'),
    document.getElementById('cmpB'), document.getElementById('swpB'), document.getElementById('statusB'), document.getElementById('winnerB'));

  // If user chose Step-by-Step, keep loops waiting for tickets
  if (ui.mode.value === 'step') {
    state.paused = false; // not paused; just waiting on tickets
    stepTickets = 0;
  }
});

ui.pause.addEventListener('click', () => { state.paused = true; });
ui.resume.addEventListener('click', () => { state.paused = false; });
ui.restart.addEventListener('click', () => {
  state.paused = true;
  stepTickets = 0;
  winnerDeclared = false; finishedA = false; finishedB = false;
  resetArrays();
});

ui.stepBtn.addEventListener('click', () => {
  // Grant one ticket to each unfinished algorithm
  let tickets = 0;
  if (!finishedA) tickets++;
  if (!finishedB) tickets++;
  stepTickets += tickets;
  state.paused = false;
});

ui.mode.addEventListener('change', () => {
  // Switching to step mode should hold at gate; race mode continues
  if (ui.mode.value === 'step') {
    state.paused = false;
    stepTickets = 0;
  } else {
    state.paused = false;
  }
});

resetArrays();

</script>
</body>
</html>
